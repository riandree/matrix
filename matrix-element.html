<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="matrix-element">
  <template>
    <style>
      :host {
        display: block;
      }

      #matrix {
        display : grid;
        grid-gap: var(--row-gap,2px) var(--column-gap,2px);
        align-items : var(--align-items,center);
        justify-items : var(--justify-items,center);
        justify-content: var(--justify-content,stretch);
        align-content: var(--align-content,stretch);
      }

      #matrix > .header {
         cursor: var(--header-cursor,pointer);
      }

      #matrix > .header.col {
        background : var(--header-background,gray);
      }

      #matrix > .header.row.col {
        background : var(--header-background,darkgray);
      }

      #matrix > .header.row {
        background : var(--header-background,lightgray);
      }

      #matrix > .cell {
         cursor: var(--cell-cursor,pointer);
      }
    </style>
    <div id="matrix" style$="grid-template-columns:{{gcols}}";>
    </div>
  </template>

  <script>
    /**
     * `matrix-element`
     * simple component that handles a matrix (an array of arrays i.e. &#39;rows&#39;) 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class MatrixElement extends Polymer.Element {

      constructor() {
          super();
      }

      static get is() { return 'matrix-element'; }
      static get properties() {
        return {
          matrix: {
            type: Array,
            value: [],
            observe : this._renderMatrix
          },
          header : {  
            type: Array, value : []
          },
          rowHeader : {  
            type: Array, value : []
          }
        };
      }

      ready() {
        super.ready();

        let template = null;
        let rowTemplate = null;
        let colTemplate = null;
        if (this.children.length > 0 && 
            this.children[0] instanceof HTMLTemplateElement){
          if (this.children.length == 1) {
            template = this.children[0];
          } else {
            template = this.querySelector("[role=cell]");
            rowTemplate = this.querySelector("[role=row]");
            colTemplate = this.querySelector("[role=col]");
          }
        } 

        this.templateClass = Polymer.Templatize.templatize(template);
        if (rowTemplate) {
          this.rowTemplateClass = Polymer.Templatize.templatize(rowTemplate);
        }
        if (colTemplate) {
          this.colTemplateClass = Polymer.Templatize.templatize(colTemplate);
        }

        this._renderMatrix();
      }

      _onGridClick(e) {
        let row=e.target.dataset.row;
        let col=e.target.dataset.col;
        
        let clickType="cell";
        if (row < 0 && col < 0) {
          clickType = "row-col-header";
        } else if (row < 0) {
          clickType = "col-header";
        } else if (col < 0) {
          clickType = "row-header";
        }

        this.$.matrix.dispatchEvent(new CustomEvent(`${clickType}-click`, {
          bubbles: true,
          composed : true,
          detail: { row , col }
        }));
      }

      _appendTextHeaderElement (params) {
            let hdrEl = document.createElement("span");
            for(let clazz of params.classes) {
              hdrEl.classList.add(clazz);
            }
            if (params.text) {
              hdrEl.textContent = params.text;
            }
            hdrEl.dataset.row=params.row;
            hdrEl.dataset.col=params.col;
            hdrEl.addEventListener('click',this._onGridClick.bind(this));
            this.$.matrix.appendChild(hdrEl);
      };

      _appendTemplate(params) {
        let instance = new params.template({item: params.item});
        this.$.matrix.appendChild(instance.root);        
       
        // ToDo improve this !!!
        for(let clazz of params.classes) {
           this.$.matrix.lastChild.previousSibling.classList.add(clazz);
        }
        this.$.matrix.lastChild.previousSibling.addEventListener('click',this._onGridClick.bind(this));
        this.$.matrix.lastChild.previousSibling.dataset.row=params.row;
        this.$.matrix.lastChild.previousSibling.dataset.col=params.col;
      }

      _appendHeader(params) {
        params.classes.push('header');
        if (params.template) {
          this._appendTemplate(params); 
        } else {
          params.text = params.item.toString(),
          this._appendTextHeaderElement(params);
        }
      }

      _renderMatrix() {
        if (this.header) {
          let col=-1;
          if (this.rowHeader) {
            this._appendHeader({
              classes : ['col','row'],
              item : "",
              row : -1,
              col : col++
            });
          }
          // render the Grid-Header if 'header' property is set
          for(let hdr of this.header) {
            this._appendHeader({
              classes : ['col'],
              item : hdr,
              template : this.colTemplateClass,
              row : -1,
              col : col++
            });
          }
        }        

        let gridCols = 0;

        // ToDo bei unterschiedlich langen Rows bis auf gleiche Länge auffüllen
        // auch im Header
        let rowHeaders = Object.assign([],this.rowHeader);
        let rowN=0; 
        for(let row of this.matrix) {
          gridCols = Math.max(gridCols,row.length)
          if (this.rowHeader) {
            this._appendHeader({
              classes : ['row'],
              item : rowHeaders.shift(),
              template : this.rowTemplateClass,
              row : rowN,
              col : -1
            });
          }
          let col=0;
          for(let columnElem of row) {
            this._appendTemplate({
              template : this.templateClass,
              row : rowN,
              col : col++,
              item : columnElem,
              classes : ['cell']
            });
//            let instance = new this.templateClass({item: columnElem});
//            this.$.matrix.appendChild(instance.root);
            // ToDo improve this !!!
//            this.$.matrix.lastChild.previousSibling.classList.add("cell");
//            this.$.matrix.lastChild.previousSibling.addEventListener('click',this._onGridClick.bind(this));
//            this.$.matrix.lastChild.previousSibling.dataset.row=rowN;
//            this.$.matrix.lastChild.previousSibling.dataset.col=col++;
          }
          rowN+=1; 
        }
        this.gcols="1fr ".repeat(this.rowHeader ? gridCols+1 : gridCols);
      }
    }

    window.customElements.define(MatrixElement.is, MatrixElement);
  </script>
</dom-module>
