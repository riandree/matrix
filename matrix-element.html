<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="matrix-element">
  <template>
    <style>
      :host {
        display: block;
      }

      #matrix {
        display : grid;
        grid-gap: var(--row-gap,2px) var(--column-gap,2px);
        align-items : var(--align-items,center);
        justify-items : var(--justify-items,center);
        justify-content: var(--justify-content,stretch);
        align-content: var(--align-content,stretch);
      }

      #matrix > .header {
         cursor: var(--header-cursor,pointer);
      }

      #matrix > .header.col {
        background : var(--header-background,gray);
      }

      #matrix > .header.row.col {
        background : var(--header-background,darkgray);
      }

      #matrix > .header.row {
        background : var(--header-background,lightgray);
      }

      #matrix > .cell {
         cursor: var(--cell-cursor,pointer);
      }
    </style>
    <div id="matrix" style$="grid-template-columns:{{gcols}}";>
    </div>
  </template>

  <script>
    /**
     * `matrix-element`
     * simple component that handles a matrix (an array of arrays i.e. &#39;rows&#39;) 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class MatrixElement extends Polymer.Element {

      constructor() {
          super();
      }

      static get is() { return 'matrix-element'; }
      static get properties() {
        return {
          matrix: {
            type: Array,
            value: [],
            observe : this._renderMatrix
          },
          header : {  
            type: Array, value : []
          },
          rowHeader : {  
            type: Array, value : []
          }
        };
      }

      ready() {
        super.ready();

        let template = null;
        let rowTemplate = null;
        let colTemplate = null;
        if (this.children.length > 0 && 
            this.children[0] instanceof HTMLTemplateElement){
          if (this.children.length == 1) {
            template = this.children[0];
          } else {
            template = this.querySelector("[role=cell]");
            rowTemplate = this.querySelector("[role=row]");
            colTemplate = this.querySelector("[role=col]");
          }
        } 

        this.templateClass = Polymer.Templatize.templatize(template);
        if (rowTemplate) {
          this.rowTemplateClass = Polymer.Templatize.templatize(rowTemplate);
        }
        if (colTemplate) {
          this.colTemplateClass = Polymer.Templatize.templatize(colTemplate);
        }

        this._renderMatrix();
      }

      _onGridClick(e) {
        let row=e.target.dataset.row;
        let col=e.target.dataset.col;
        
        let clickType="cell";
        if (row < 0 && col < 0) {
          clickType = "row-col-header";
        } else if (row < 0) {
          clickType = "col-header";
        } else if (col < 0) {
          clickType = "row-header";
        }

        this.$.matrix.dispatchEvent(new CustomEvent(`${clickType}-click`, {
          bubbles: true,
          composed : true,
          detail: { row , col }
        }));
      }

      _renderMatrix() {
        if (this.header) {
          let col=-1;
          if (this.rowHeader) {
            let rowColHdr=document.createElement('header');
            rowColHdr.classList.add("header");
            rowColHdr.classList.add("col");
            rowColHdr.classList.add("row");
            rowColHdr.dataset.row=-1;
            rowColHdr.dataset.col=col++;
            rowColHdr.addEventListener('click',this._onGridClick.bind(this));
            this.$.matrix.appendChild(rowColHdr);
          }
          // render the Grid-Header if 'header' property is set
          for(let hdr of this.header) {
            let hdrHeader=document.createElement('header');
            hdrHeader.classList.add("header");
            hdrHeader.classList.add("col");
            hdrHeader.textContent = hdr.toString();
            hdrHeader.dataset.row=-1;
            hdrHeader.dataset.col=col++;
            hdrHeader.addEventListener('click',this._onGridClick.bind(this));
            this.$.matrix.appendChild(hdrHeader);            
          }
        }        

        let gridCols = 0;
        
        // ToDo bei unterschiedlich langen Rows bis auf gleiche Länge auffüllen
        // auch im Header
        let rowHeaders = Object.assign([],this.rowHeader);
        let rowN=0; 
        for(let row of this.matrix) {
          gridCols = Math.max(gridCols,row.length)
          if (this.rowHeader) {
            let rowHdr=document.createElement('header');
            rowHdr.classList.add("header");
            rowHdr.classList.add("row");
            rowHdr.textContent=rowHeaders.shift();
            rowHdr.dataset.row=rowN;
            rowHdr.dataset.col=-1;
            rowHdr.addEventListener('click',this._onGridClick.bind(this));
            this.$.matrix.appendChild(rowHdr);
          }
          let col=0;
          for(let columnElem of row) {
            let instance = new this.templateClass({item: columnElem});
            this.$.matrix.appendChild(instance.root);
            // ToDo improve this !!!
            this.$.matrix.lastChild.previousSibling.classList.add("cell");
            this.$.matrix.lastChild.previousSibling.addEventListener('click',this._onGridClick.bind(this));
            this.$.matrix.lastChild.previousSibling.dataset.row=rowN;
            this.$.matrix.lastChild.previousSibling.dataset.col=col++;
          }
          rowN+=1; 
        }
        this.gcols="1fr ".repeat(this.rowHeader ? gridCols+1 : gridCols);
      }
    }

    window.customElements.define(MatrixElement.is, MatrixElement);
  </script>
</dom-module>
